# CoordCard v0.2 Proposal — Reference Repair Choreography Profile

Status: **draft** (proposal only; no schema/code changes yet)

## Motivation
v0.1 is deterministic in **triggering + rule traceability**, but ambiguous in **what happens next** once repair is initiated.

Different implementers can remain “v0.1 compliant” while producing divergent repair behavior (different step ordering, advancement criteria, what counts as success). This creates entropy and reduces interoperability.

## Goal (v0.2)
Add a **portable, explicit reference choreography** for the repair loop while avoiding early hardening into a full state machine.

- Keep KISS.
- Keep scoring assistive.
- Keep `nextStep` deterministic and auditable.
- Make “next behavior” less interpretive.

## Non-goals (v0.2)
- Not a telemetry layer
- Not sentiment/NLP sophistication
- Not an enforcement engine
- Not an orchestration framework
- Not a required state machine (no mandated runtime)

## Proposed additions (minimal surface area)

### 1) `repair_loop.choreography`
A new object that defines a **reference profile** and its sequence.

```jsonc
{
  "repair_loop": {
    "choreography": {
      "profile": "default_v0_2",
      "sequence": [
        "pause",
        "restate_invariants",
        "specificity",
        "reversible_test",
        "checkpoint"
      ],
      "hold_policy": {
        "max_cycles_per_step": 2,
        "timeout_action": "vent.tighten_scope"
      },
      "advance_conditions": {
        "pause": { "min_cycles": 1 },
        "restate_invariants": { "requires": ["invariant_ids"] },
        "specificity": { "requires": ["constraints", "falsifiable_claim"] },
        "reversible_test": { "requires": ["test_description", "test_timebox", "success_criteria"] },
        "checkpoint": { "requires": ["rho_trend"] }
      }
    }
  }
}
```

Notes:
- This is **reference choreography**. Implementers MAY follow it exactly, or use it as a default.
- The `requires` keys refer to structured “inputs” (see below).

### 2) `repair_loop.inputs` (structured)
A small, optional dictionary describing the **inputs** that a repair step can request.

```jsonc
{
  "repair_loop": {
    "inputs": {
      "constraints": { "type": "string", "description": "Constraints/bounds for the discussion or decision." },
      "falsifiable_claim": { "type": "string", "description": "A claim that can be tested/refuted." },
      "invariant_ids": { "type": "array", "items": "string" },
      "test_description": { "type": "string" },
      "test_timebox": { "type": "string" },
      "success_criteria": { "type": "string" },
      "rho_trend": { "type": "string", "enum": ["up", "flat", "down"] }
    }
  }
}
```

Notes:
- v0.2 does NOT require any particular tool to populate these.
- They can be filled manually by a human operator, or extracted by downstream tooling.

### 3) Template placeholders alignment
Templates already exist in v0.1. v0.2 simply **names the placeholders** in a way that aligns with `repair_loop.inputs`.

Example: `restate_invariants` template uses `{{invariant_ids}}`.

### 4) Optional: `repair_loop.choreography_note`
A short human-readable note for implementers.

## Backward compatibility
- v0.2 is an additive extension. A v0.1 card remains valid.
- A v0.2-aware implementation should treat missing `repair_loop.choreography` as “use v0.1 behavior”.

## Determinism + auditability
The reference implementation should keep:
- deterministic next-step selection
- rule traceability: `triggerFired`, `ruleSource`, `ruleText`

v0.2 adds a second traceability axis:
- `choreography.profile` and whether the selection followed the reference sequence.

## Example: minimal v0.2 card delta
```jsonc
{
  "repair_loop": {
    "choreography": {
      "profile": "default_v0_2",
      "sequence": ["pause","restate_invariants","specificity","reversible_test","checkpoint"]
    }
  }
}
```

## Open questions
1) Should `max_cycles_per_step` default to 1 or 2?
2) Should `timeout_action` default to `vent.tighten_scope` or `repair.specificity`?
3) Should `inputs` be enumerated/fixed for v0.2, or allow arbitrary keys?

## Acceptance criteria for v0.2
- Schema updated to allow (optional) `repair_loop.choreography` and `repair_loop.inputs`.
- Add one v0.2 example payload.
- Update TS ref impl to (optionally) follow the reference sequence.
- Keep implementation minimal; avoid feature creep.
